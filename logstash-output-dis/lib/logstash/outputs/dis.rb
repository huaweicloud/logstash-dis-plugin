require 'logstash/namespace'
require 'logstash/outputs/base'
require 'java'
require 'logstash-output-dis_jars.rb'

java_import com.huaweicloud.dis.adapter.kafka.clients.producer.ProducerRecord

# Write events to a DIS stream, using DIS Kafka Adapter.
class LogStash::Outputs::Dis < LogStash::Outputs::Base
  declare_threadsafe!

  config_name 'dis'

  default :codec, 'plain'

  # The number of acknowledgments the producer requires the leader to have received
  # before considering a request complete.
  #
  # acks=0,   the producer will not wait for any acknowledgment from the server at all.
  # acks=1,   This will mean the leader will write the record to its local log but
  #           will respond without awaiting full acknowledgement from all followers.
  # acks=all, This means the leader will wait for the full set of in-sync replicas to acknowledge the record.
  config :acks, :validate => ["0", "1", "all"], :default => "1"
  # The producer will attempt to batch records together into fewer requests whenever multiple
  # records are being sent to the same partition. This helps performance on both the client
  # and the server. This configuration controls the default batch size in bytes.
  config :batch_size, :validate => :number, :default => 16384
  # This is for bootstrapping and the producer will only use it for getting metadata (topics,
  # partitions and replicas). The socket connections for sending the actual data will be
  # established based on the broker information returned in the metadata. The format is
  # `host1:port1,host2:port2`, and the list can be a subset of brokers or a VIP pointing to a
  # subset of brokers.
  config :bootstrap_servers, :validate => :string, :default => 'localhost:9092'

  config :block_on_buffer_full, :validate => :boolean, :obsolete => "This options is obsolete"
  # The total bytes of memory the producer can use to buffer records waiting to be sent to the server.
  config :buffer_memory, :validate => :number, :default => 33554432
  # The compression type for all data generated by the producer.
  # The default is none (i.e. no compression). Valid values are none, gzip, or snappy.
  config :compression_type, :validate => ["none", "gzip", "snappy", "lz4"], :default => "none"
  # The id string to pass to the server when making requests.
  # The purpose of this is to be able to track the source of requests beyond just
  # ip/port by allowing a logical application name to be included with the request
  config :client_id, :validate => :string
  # Serializer class for the key of the message
  config :key_serializer, :validate => :string, :default => 'com.huaweicloud.dis.adapter.kafka.common.serialization.StringSerializer'
  # The producer groups together any records that arrive in between request
  # transmissions into a single batched request. Normally this occurs only under
  # load when records arrive faster than they can be sent out. However in some circumstances
  # the client may want to reduce the number of requests even under moderate load.
  # This setting accomplishes this by adding a small amount of artificial delayâ€”that is,
  # rather than immediately sending out a record the producer will wait for up to the given delay
  # to allow other records to be sent so that the sends can be batched together.
  config :linger_ms, :validate => :number, :default => 0
  # The maximum size of a request
  config :max_request_size, :validate => :number, :default => 1048576
  # The key for the message
  config :message_key, :validate => :string
  # the timeout setting for initial metadata request to fetch topic metadata.
  config :metadata_fetch_timeout_ms, :validate => :number, :default => 60000
  # the max time in milliseconds before a metadata refresh is forced.
  config :metadata_max_age_ms, :validate => :number, :default => 300000
  # The size of the TCP receive buffer to use when reading data
  config :receive_buffer_bytes, :validate => :number, :default => 32768
  # The amount of time to wait before attempting to reconnect to a given host when a connection fails.
  config :reconnect_backoff_ms, :validate => :number, :default => 10
  # The configuration controls the maximum amount of time the client will wait
  # for the response of a request. If the response is not received before the timeout
  # elapses the client will resend the request if necessary or fail the request if
  # retries are exhausted.
  config :request_timeout_ms, :validate => :string
  # The default retry behavior is to retry until successful. To prevent data loss,
  # the use of this setting is discouraged.
  #
  # If you choose to set `retries`, a value greater than zero will cause the
  # client to only retry a fixed number of times. This will result in data loss
  # if a transient error outlasts your retry count.
  #
  # A value less than zero is a configuration error.
  config :retries, :validate => :number
  # The amount of time to wait before attempting to retry a failed produce request to a given topic partition.
  config :retry_backoff_ms, :validate => :number, :default => 100
  # The size of the TCP send buffer to use when sending data.
  config :send_buffer_bytes, :validate => :number, :default => 131072

  config :timeout_ms, :validate => :number, :obsolete => "This option is obsolete. Please use request_timeout_ms"

  # The DIS stream to produce messages to
  config :stream, :validate => :string, :required => true
  # If this is enabled, we will map topic to DIS stream name automatically
  config :auto_stream_mapping_enabled, :default => false
  # DIS Gateway endpoint
  config :endpoint, :validate => :string, :default => "https://dis.cn-north-1.myhuaweicloud.com:20004"
  # The ProjectId of the specified region, it can be obtained from My Credential Page
  config :project_id, :validate => :string
  # Specifies use which region of DIS, now DIS only support cn-north-1
  config :region, :validate => :string, :default => "cn-north-1"
  # The Access Key ID for hwclouds, it can be obtained from My Credential Page
  config :ak, :validate => :string
  # The Secret key ID is encrypted or not
  config :is_sk_encrypted, :default => false
  # The encrypt key used to encypt the Secret Key Id
  config :encrypt_key, :validate => :string
  # The Secret Key ID for hwclouds, it can be obtained from My Credential Page
  config :sk, :validate => :string
  # Serializer class for the value of the message
  config :value_serializer, :validate => :string, :default => 'com.huaweicloud.dis.adapter.kafka.common.serialization.StringSerializer'

  public
  def register
    @thread_batch_map = Concurrent::Hash.new

    if !@retries.nil? 
      if @retries < 0
        raise ConfigurationError, "A negative retry count (#{@retries}) is not valid. Must be a value >= 0"
      end

      @logger.warn("Kafka output is configured with finite retry. This instructs Logstash to LOSE DATA after a set number of send attempts fails. If you do not want to lose data if Kafka is down, then you must remove the retry setting.", :retries => @retries)
    end


    @producer = create_producer
    if value_serializer == 'com.huaweicloud.dis.adapter.kafka.common.serialization.StringSerializer'
      @codec.on_event do |event, data|
        write_to_dis(event, data)
      end
    elsif value_serializer == 'com.huaweicloud.dis.adapter.kafka.common.serialization.ByteArraySerializer'
      @codec.on_event do |event, data|
        write_to_dis(event, data.to_java_bytes)
      end
    else
      raise ConfigurationError, "'value_serializer' only supports com.huaweicloud.dis.adapter.kafka.common.serialization.ByteArraySerializer and com.huaweicloud.dis.adapter.kafka.common.serialization.StringSerializer" 
    end
  end

  # def register

  def prepare(record)
    # This output is threadsafe, so we need to keep a batch per thread.
    @thread_batch_map[Thread.current].add(record)
  end

  def multi_receive(events)
    t = Thread.current
    if !@thread_batch_map.include?(t)
      @thread_batch_map[t] = java.util.ArrayList.new(events.size)
    end

    events.each do |event|
      break if event == LogStash::SHUTDOWN
      @codec.encode(event)
    end

    batch = @thread_batch_map[t]
    if batch.any?
      retrying_send(batch)
      batch.clear
    end
  end

  def retrying_send(batch)
    remaining = @retries;

    while batch.any?
      if !remaining.nil?
        if remaining < 0
          # TODO(sissel): Offer to DLQ? Then again, if it's a transient fault,
          # DLQing would make things worse (you dlq data that would be successful
          # after the fault is repaired)
          logger.info("Exhausted user-configured retry count when sending to Kafka. Dropping these events.",
                      :max_retries => @retries, :drop_count => batch.count)
          break
        end

        remaining -= 1
      end

      failures = []

      futures = batch.collect do |record| 
        begin
          # send() can throw an exception even before the future is created.
          @producer.send(record)
        rescue org.apache.kafka.common.errors.TimeoutException => e
          failures << record
          nil
        rescue org.apache.kafka.common.errors.InterruptException => e
          failures << record
          nil
        rescue com.huaweicloud.dis.adapter.kafka.common.errors.SerializationException => e
          # TODO(sissel): Retrying will fail because the data itself has a problem serializing.
          # TODO(sissel): Let's add DLQ here.
          failures << record
          nil
        end
      end.compact

      futures.each_with_index do |future, i|
        begin
          result = future.get()
        rescue => e
          # TODO(sissel): Add metric to count failures, possibly by exception type.
          logger.warn("KafkaProducer.send() failed: #{e}", :exception => e)
          failures << batch[i]
        end
      end

      # No failures? Cool. Let's move on.
      break if failures.empty?

      # Otherwise, retry with any failed transmissions
      batch = failures
      delay = @retry_backoff_ms / 1000.0
      logger.info("Sending batch to Kafka failed. Will retry after a delay.", :batch_size => batch.size,
                  :failures => failures.size, :sleep => delay);
      sleep(delay)
    end

  end

  def close
    @producer.close
  end

  private

  def write_to_dis(event, serialized_data)
    if auto_stream_mapping_enabled
      stream = event.get("@metadata").fetch("kafka").fetch("topic");
    else
      stream = @stream;
    end

    if @message_key.nil?
      message_key = event.get("table");
    else
      message_key = @message_key;
    end
    
    if message_key.nil?
      # record = ProducerRecord.new(event.sprintf(@stream), serialized_data)
      record = ProducerRecord.new(stream, serialized_data)
    else
      # record = ProducerRecord.new(event.sprintf(@stream), event.sprintf(@message_key), serialized_data)
      # record = ProducerRecord.new(stream, event.sprintf(@message_key), serialized_data)
      record = ProducerRecord.new(stream, message_key, serialized_data)
    end
    prepare(record)
  rescue LogStash::ShutdownSignal
    @logger.debug('DIS Kafka producer got shutdown signal')
  rescue => e
    @logger.warn('DIS kafka producer threw exception, restarting',
                 :exception => e)
  end

  def create_producer
    begin
      props = java.util.Properties.new
      kafka = com.huaweicloud.dis.adapter.kafka.clients.producer.ProducerConfig

      props.put("IS_DEFAULT_TRUSTED_JKS_ENABLED", "false")
      # props.put(kafka::BATCH_SIZE_CONFIG, batch_size.to_s)
      # props.put(kafka::BOOTSTRAP_SERVERS_CONFIG, bootstrap_servers)
      # props.put(kafka::BUFFER_MEMORY_CONFIG, buffer_memory.to_s)
      # props.put(kafka::COMPRESSION_TYPE_CONFIG, compression_type)
      # props.put(kafka::CLIENT_ID_CONFIG, client_id) unless client_id.nil?
      props.put("key.deserializer", "com.huaweicloud.dis.adapter.kafka.common.serialization.StringDeserializer")
      # props.put(kafka::LINGER_MS_CONFIG, linger_ms.to_s)
      # props.put(kafka::MAX_REQUEST_SIZE_CONFIG, max_request_size.to_s)
      # props.put(kafka::RECONNECT_BACKOFF_MS_CONFIG, reconnect_backoff_ms) unless reconnect_backoff_ms.nil?
      # props.put(kafka::REQUEST_TIMEOUT_MS_CONFIG, request_timeout_ms) unless request_timeout_ms.nil?
      # props.put(kafka::RETRIES_CONFIG, retries.to_s) unless retries.nil?
      # props.put(kafka::RETRY_BACKOFF_MS_CONFIG, retry_backoff_ms.to_s) 
      # props.put(kafka::SEND_BUFFER_CONFIG, send_buffer_bytes.to_s)
      props.put("value.deserializer", "com.huaweicloud.dis.adapter.kafka.common.serialization.StringDeserializer")

      # endpoint, project_id, region, ak, sk
      props.put("endpoint", endpoint)
      props.put("projectId", project_id)
      props.put("region", region)
      props.put("ak", ak)
      if is_sk_encrypted
        decrypted_sk = decrypt(@sk)
        props.put("sk", decrypted_sk)
      else
        props.put("sk", sk)
      end


      com.huaweicloud.dis.adapter.kafka.clients.producer.DISKafkaProducer.new(props)
    rescue => e
      logger.error("Unable to create DIS Kafka producer from given configuration",
                   :kafka_error_message => e,
                   :cause => e.respond_to?(:getCause) ? e.getCause() : nil)
      raise e
    end
  end

  private
  def decrypt(encrypted_sk)
    com.huaweicloud.dis.util.encrypt.EncryptUtils.dec([@encrypt_key].to_java(java.lang.String), encrypted_sk)
  rescue => e
    logger.error("Unable to decrypt sk from given configuration",
                  :decrypt_error_message => e,
                  :cause => e.respond_to?(:getCause) ? e.getCause() : nil)
  end

end #class LogStash::Outputs::Dis
